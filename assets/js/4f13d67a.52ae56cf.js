"use strict";(self.webpackChunkfirefox_ecosystem_platform=self.webpackChunkfirefox_ecosystem_platform||[]).push([[1412],{24111:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(87462),s=(n(67294),n(3905));n(29420);const o={title:"Session Tokens"},i="FxA Session Tokens",l={unversionedId:"explanation/session-tokens",id:"explanation/session-tokens",title:"Session Tokens",description:"This is a bit of a braindump, but here we are.",source:"@site/docs/explanation/session-tokens.md",sourceDirName:"explanation",slug:"/explanation/session-tokens",permalink:"/ecosystem-platform/explanation/session-tokens",draft:!1,editUrl:"https://github.com/mozilla/ecosystem-platform/edit/master/docs/explanation/session-tokens.md",tags:[],version:"current",frontMatter:{title:"Session Tokens"},sidebar:"docs",previous:{title:"Content-server architecture",permalink:"/ecosystem-platform/explanation/content-server-architecture"},next:{title:"Additional Docs",permalink:"/ecosystem-platform/additional-docs"}},r={},u=[{value:"Session Token Maximums and Token Pruning",id:"session-token-maximums-and-token-pruning",level:2},{value:"Prune Tokens Script",id:"prune-tokens-script",level:3}],d={toc:u};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"fxa-session-tokens"},"FxA Session Tokens"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"This is a bit of a braindump, but here we are.")),(0,s.kt)("p",null,"Initially, session tokens were just stored in MySQL with everything else. As part of some work to enable the device manager, we added columns for parsed user-agent info and last-access time, along with a new stored procedure to update a token:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-db-mysql/pull/65"},"https://github.com/mozilla/fxa-auth-db-mysql/pull/65")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/997"},"https://github.com/mozilla/fxa-auth-server/pull/997"))),(0,s.kt)("p",null,"However, when we turned it on in prod it caused a significant increase in write IOPS and it had to be backed out:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/1169"},"https://github.com/mozilla/fxa-auth-server/pull/1169")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/1171"},"https://github.com/mozilla/fxa-auth-server/pull/1171"))),(0,s.kt)("p",null,"So, the decision was taken to move just the new properties into Redis and then aggregate tokens from the two data stores when reading them out:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/1968"},"https://github.com/mozilla/fxa-auth-server/pull/1968"))),(0,s.kt)("p",null,"Later, the size of our Redis instance became a growing concern and we did some work to reduce it by removing property keys and by pruning old tokens:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/2254"},"https://github.com/mozilla/fxa-auth-server/pull/2254")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/2257"},"https://github.com/mozilla/fxa-auth-server/pull/2257"))),(0,s.kt)("p",null,"The latter of those two changes mirrored work that we previously did to prune old session tokens from MySQL:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-server/pull/1996"},"https://github.com/mozilla/fxa-auth-server/pull/1996")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-auth-db-mysql/pull/282"},"https://github.com/mozilla/fxa-auth-db-mysql/pull/282"))),(0,s.kt)("p",null,"Session tokens in MySQL can be associated with a device record. \u201cDevice\u201d is a misleading name here because it really means \u201cFirefox instance\u201d. A true device record would require some kind of reliable fingerprinting mechanism so we could recognise common devices between instances of the browser. When we started tracking metrics for how many devices a user connected, we tried to make accommodations for this by taking into account the operating system details. But in most places in the code, bear in mind that device === browser."),(0,s.kt)("p",null,"A session token that has a device record will never be pruned, because that would break Sync. So we only prune tokens if there\u2019s no corresponding device in the db. And we only prune them if they\u2019re more than 4 weeks old."),(0,s.kt)("p",null,"Pruning from MySQL happens in one of our regular versioned stored procedures, at the time of writing it\u2019s called ",(0,s.kt)("inlineCode",{parentName:"p"},"prune_7"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"packages/fxa-auth-db-mysql/lib/db/schema/patch-068-069.sql")),(0,s.kt)("p",null,"There are properties in config that control this called enablePruning, pruneEvery and pruneTokensMaxAge. The code that uses them is near the top of ",(0,s.kt)("inlineCode",{parentName:"p"},"lib/db/mysql.js")," in the ",(0,s.kt)("inlineCode",{parentName:"p"},"fxa-auth-db-mysql")," package."),(0,s.kt)("p",null,"Pruning from Redis happens opportunistically whenever session tokens are read by calling ",(0,s.kt)("inlineCode",{parentName:"p"},"db.pruneSessionTokens"),". This method is called automatically on every endpoint that is authenticated by session token, via code inside ",(0,s.kt)("inlineCode",{parentName:"p"},"makeCredentialFn")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"lib/server.js")," in the ",(0,s.kt)("inlineCode",{parentName:"p"},"fxa-auth-server")," package. I just noticed it\u2019s also explicitly called by ",(0,s.kt)("inlineCode",{parentName:"p"},"db.sessions")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"lib/db.js"),", which seems unnecessary. Perhaps that is an artifact of some older arrangement, I can\u2019t remember now. We may be able to get rid of it."),(0,s.kt)("p",null,"There are also explicit calls to ",(0,s.kt)("inlineCode",{parentName:"p"},"db.deleteSessionTokenFromRedis")," in all of the places it makes sense to do so. That includes ",(0,s.kt)("inlineCode",{parentName:"p"},"db.createSessionToken"),", to handle any occurrences where a session token id gets reused and the old session token still had data in Redis."),(0,s.kt)("h2",{id:"session-token-maximums-and-token-pruning"},"Session Token Maximums and Token Pruning"),(0,s.kt)("p",null,"This an update on session tokens and pruning. The previous section will remain intact for historical record."),(0,s.kt)("p",null,"In 2022, we discovered that some accounts had ended up with extremely large numbers of devices. This can be a bit of liability from a data perspective and we have decided to start applying limits to the number of sessions an account can reference. As mentioned above there is a relationship between devices and sessions, so this effectively also limits the number of devices an account can support (i.e. have signed in) at any given time. At the time of writing we are limiting accounts to 1000 active sessions."),(0,s.kt)("p",null,"We enforce these limits in a few ways. First we only allow N sessions to be held per account in redis. Second, we limit on sql queries to N sessions, and finally we actively remove, aka prune, sessions for accounts with more than 1000 sessions."),(0,s.kt)("p",null,"Previously the prune would happen opportunistically and randomly in a fire and forget to call in the server. It would occur when a user accessed their account at random (i.e. not every access would result in a prune). At one point this fire and forget operation was unintentionally disabled during a refactor. This led to extremely high session counts, and we actually encountered some OOM errors in code due to unbound sql queries returning too many sessions. These sql queries have all been bounded, and we decided to move the pruning operation to a cron job, so the operation could be applied regularly and be monitored."),(0,s.kt)("p",null,"The script that prunes tokens, and tokens of all kinds is called (prune-tokens.ts)","[https://github.com/mozilla/fxa/blob/main/packages/fxa-auth-server/scripts/prune-tokens.ts]",". It has multiple arguments, and is sort of complicated in its own right and will be documented here."),(0,s.kt)("h3",{id:"prune-tokens-script"},"Prune Tokens Script"),(0,s.kt)("p",null,"The script itself goes through the following stages."),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Locates accounts with more than N sessions. (Where N is the maximum number of allowed sessions.)"),(0,s.kt)("li",{parentName:"ol"},"Targets the accounts with the most sessions first and begins deleting these sessions."),(0,s.kt)("li",{parentName:"ol"},"Targets all tokens older than N number of days (Where N is the max number of days.)"),(0,s.kt)("li",{parentName:"ol"},"Delete these tokens excluding any session token associated with a device."),(0,s.kt)("li",{parentName:"ol"},"Targets all codes older than N number of days (Where N is the max number of days.)"),(0,s.kt)("li",{parentName:"ol"},"Deletes these codes.")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"(Steps 3-6 are the legacy process described at the start of this document.)")),(0,s.kt)("p",null,"Help for the script can be viewed by running ",(0,s.kt)("inlineCode",{parentName:"p"},"NODE_ENV=dev node prune-tokens.js --help"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"NODE_ENV=dev node prune-tokens.js --help\nUsage: prune-tokens [options]\n\n\nOptions:\n\n\n -V, --version                       output the version number\n --maxTokenAge <duration>            Max age of token. Any tokens older than this value will be pruned. A value of 0 results in a no-op. (default: 0)\n --maxCodeAge <duration>             Max age of code. Any codes older than this value will be pruned. A value of 0 results in a no-op. (default: 0)\n --maxSessions <number>              Max number of sessions that any account is allowed to hold. A value of 0 results in a no-op. (default: 0)\n --maxSessionsMaxAccounts <number>   When maxSessions is greater than 0, this value allows us to limit scope of the delete by restricting the number of accounts processed on any given run. (default: 100)\n --maxSessionsMaxDeletions <number>  When maxSessions is greater than 0, this value restricts the total number of sessions that can be deleted per account. (default: 100000)\n --maxSessionsBatchSize <number>     When maxSessions is greater than 0, this value controls the number of deletions that are batched together at one time. e.g. A batch size of 1 would delete one token at a time. (default: 1000)\n --wait                              Amount of time to sleep between delete operations in milliseconds.\n -h, --help                          output usage information\n\n\nExample:\n\n\n> ./scripts/prune-tokens.sh --maxTokenAge='10 days' --maxCodeAge='1 month' --maxSessions=500\n\n\nExit Codes:\n 0 - success\n 1 - unexpected error\n 2 - error during initialization\n 3 - error during pruning operation\n")),(0,s.kt)("p",null,"There's quite a few options here, so let's break this down with an example. Let's say we invoked the token pruner with this:"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"NODE_ENV=dev node prune-tokens.js --maxTokenAge 30-days --maxCodeAge 30-days --maxSessions=1000 --maxSessionsMaxAccounts=1 --maxSessionsMaxDeletions=100000 --maxSessionsBatchSize=1 --wait=500")),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxTokenAge 30-days")," - Any token older than 30 days would be pruned, except for session tokens with associated devices."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxCodeAge 30-days")," - Any token code older than 30 days would be pruned."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxSessions=1000")," - This means an account can have up to 1000 sessions, anything over 1000, is fair game to delete."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxSessionsMaxAccounts=1")," - This means that  we target up to 1 account per run."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxSessionsMaxDeletions=100000")," - This means we will delete up to 100k tokens per account, then give up and move onto the next account. In our case we only have one account, so we would exit after 100k were deleted. (again 100k not 10k\u2026)"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--maxSessionBatchSize=1")," - This means that we delete 1 token at a time. It used to be higher, but when we started hitting perf issues on stage, we turned this way down."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"--wait=500")," - Wait 500ms between each delete call. So in this case, delete 1 token. wait 500ms, delete another token.")),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Note, any argument that starts with ",(0,s.kt)("inlineCode",{parentName:"em"},"maxSession")," is a session specific arg, which control steps 1 & 2 of the pruning process.")))}p.isMDXComponent=!0}}]);