"use strict";(self.webpackChunkfirefox_ecosystem_platform=self.webpackChunkfirefox_ecosystem_platform||[]).push([[8545],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||o;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},89303:function(e,t,n){n.r(t),n.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return u},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return d}});var a=n(87462),i=n(63366),o=(n(67294),n(3905)),r=["components"],s={title:"Scoped Keys"},l=void 0,p={unversionedId:"explanation/scoped-keys",id:"explanation/scoped-keys",title:"Scoped Keys",description:"Scoped Encryption Keys for Firefox Accounts",source:"@site/docs/explanation/scoped-keys.md",sourceDirName:"explanation",slug:"/explanation/scoped-keys",permalink:"/ecosystem-platform/explanation/scoped-keys",draft:!1,editUrl:"https://github.com/mozilla/ecosystem-platform/edit/master/docs/explanation/scoped-keys.md",tags:[],version:"current",frontMatter:{title:"Scoped Keys"},sidebar:"docs",previous:{title:"onepw Protocol",permalink:"/ecosystem-platform/explanation/onepw-protocol"},next:{title:"Content-server architecture",permalink:"/ecosystem-platform/explanation/content-server-architecture"}},c={},d=[{value:"Scoped Encryption Keys for Firefox Accounts",id:"scoped-encryption-keys-for-firefox-accounts",level:2},{value:"Background",id:"background",level:3},{value:"Requirements",id:"requirements",level:3},{value:"Data Model",id:"data-model",level:3},{value:"Protocol Flow",id:"protocol-flow",level:3},{value:"Key Rotation and Revocation",id:"key-rotation-and-revocation",level:3},{value:"Deriving Scoped Keys (kS)",id:"deriving-scoped-keys-ks",level:3},{value:"Application Specific Keys",id:"application-specific-keys",level:4},{value:"Applications with a Service Component",id:"applications-with-a-service-component",level:4},{value:"Granting Access to Sync Data",id:"granting-access-to-sync-data",level:3},{value:"Test Vectors (WIP)",id:"test-vectors-wip",level:3},{value:"Risks and Mitigations",id:"risks-and-mitigations",level:3},{value:"Exposure of key material to FxA servers",id:"exposure-of-key-material-to-fxa-servers",level:4},{value:"Exposure of key material to relying application servers",id:"exposure-of-key-material-to-relying-application-servers",level:4},{value:"Side-channel leaks from Web Content",id:"side-channel-leaks-from-web-content",level:4},{value:"Interception by another application",id:"interception-by-another-application",level:4},{value:"Theft of keys from client application",id:"theft-of-keys-from-client-application",level:4},{value:"Shared redirect_uri origins",id:"shared-redirect_uri-origins",level:4},{value:"Revocation",id:"revocation",level:4},{value:"Additional Notes and Content",id:"additional-notes-and-content",level:3}],h={toc:d};function u(e){var t=e.components,s=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},h,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"scoped-encryption-keys-for-firefox-accounts"},"Scoped Encryption Keys for Firefox Accounts"),(0,o.kt)("p",null,"The ability to provide secure access to per-user encryption keys is a major differentiator for Firefox Accounts over other identity providers.  Indeed, the requirement for client-side encryption keys in Firefox Sync is the main reason that Mozilla develops Firefox Accounts in-house rather than using an existing identity system."),(0,o.kt)("p",null,"However, it's currently hard to use this capability for any application other than Firefox Sync,  because key material can only be accessed through a bespoke authorization protocol that is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Complex to implement."),"  The application has to either directly perform cryptographic operations on the user's account credentials, or to embed web content from accounts.firefox.com.  Keys are not available in the OAuth authorization flow which we prefer to use for new application integrations."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Far too powerful."),"  The protocol gives the application complete control of the user's Firefox Account, and hands it a copy of their master key material.  There is currently no provision for scoping access down to a subset of data or capabilities.")),(0,o.kt)("p",null,"Since end-to-end encryption is an important part of Mozilla's story around user privacy and security, we want to make it ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"easier"))," for the next generation of Firefox applications to use the encryption capabilities offered by Firefox Accounts, while giving users ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"more control"))," over the  capabilities granted to each application."),(0,o.kt)("p",null,"From short-term to long-term, the things we'd like to support with this work are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Enable other teams at Mozilla to quickly prototype new apps and services that use end-to-end encryption, bootstrapping from the existing FxA user-base.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'Example: "Lockbox", a password-management service with a WebExtension for desktop Firefox and a stand-alone mobile app, that encrypts passwords for storage in the cloud.'),(0,o.kt)("li",{parentName:"ul"},'Example: "',(0,o.kt)("a",{parentName:"li",href:"https://github.com/mozilla/notes"},"Firefox Notes"),'", a note-taking extension for Firefox that encrypts data for backing up in the cloud.'))),(0,o.kt)("li",{parentName:"ul"},"Allow new applications to access a user's sync data in a controlled way, with explicit user permission.",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},'Example: a new version of the "Prox" mobile app that can pull down the user\'s history information to make better suggestions, but is not able to access other data from Firefox Sync.'),(0,o.kt)("li",{parentName:"ul"},"Example: a single-page-web-app bookmarks viewer that can pull in bookmarks data from Firefox Sync."))),(0,o.kt)("li",{parentName:"ul"},"Encourage an ecosystem of third-party applications that can easily incorporate end-to-end encryption by securely obtaining key material from Firefox Accounts.")),(0,o.kt)("p",null,"To achieve this, we propose an extension to the standard OAuth authorization flow by which relying applications can obtain encryption keys in a secure and controlled manner."),(0,o.kt)("h3",{id:"background"},"Background"),(0,o.kt)("p",null,"We assume some familiarity with the basic data model of Firefox Accounts, as described in the ",(0,o.kt)("a",{parentName:"p",href:"onepw-protocol"},"onepw protocol document"),"."),(0,o.kt)("p",null,"While there is significantly more detail at the above link, the main points necessary for understanding our proposal are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A server-side component (the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},'"FxA server"')),") stores user account data and provides access to it through an authenticated HTTP API.  Alongside the usual account information such as email address and hashed password verifier, each user has a randomly-generated 32-byte key which we call ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapKb"),", and which can only be retrieved by proving knowledge of the user's account password.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Authenticating to the FxA server API is done through web content loaded from ",(0,o.kt)("a",{parentName:"p",href:"https://accounts.firefox.com"},"https://accounts.firefox.com")," (the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},'"FxA web content"')),").  This web content is what provides the current Sync login UI for Firefox and the authentication UI for current FxA OAuth reliers. It is the only component of the system that sees the user's plaintext account password.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"When an application needs to connect to Firefox Sync, it performs the following steps:"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The application loads FxA web content inside an embedded web runtime, and listens for custom message events.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The FxA web content prompts for the user's account password, stretches it via PBKDF2, then uses HKDF to derive two distinct 32-byte values: an authenticator ",(0,o.kt)("inlineCode",{parentName:"p"},"authPW")," which it can pass to the server to prove knowledge of the password, and a private 32-byte key which we call ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrapBKey"),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The web content passes ",(0,o.kt)("inlineCode",{parentName:"p"},"authPW")," to the FxA server and receives two tokens in return: a long-lived ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"session token"))," that is used to authenticate subsequent API calls, and a single-use ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"key fetch token"))," with which it can retrieve the user's ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapKb"),".  It messages these along with ",(0,o.kt)("inlineCode",{parentName:"p"},"unwrapBKey")," back to the client application."))))),(0,o.kt)("p",null,"The application fetches ",(0,o.kt)("inlineCode",{parentName:"p"},"wrapKb")," from the FxA server, then calculates the user's ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"master key material"))," via xor: ",(0,o.kt)("inlineCode",{parentName:"p"},"kB = wrapkB \u2295 unwrapBKey"),"."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"A simplified diagram of connecting to Firefox Sync",src:n(56750).Z,width:"1597",height:"980"})),(0,o.kt)("p",null,"Constructing the master key material ",(0,o.kt)("inlineCode",{parentName:"p"},"kB")," from two separate components in this manner gives the system some interesting security properties:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"The FxA server never sees the user's raw password or their ",(0,o.kt)("inlineCode",{parentName:"li"},"kB"),", thanks to the inclusion of ",(0,o.kt)("inlineCode",{parentName:"li"},"unwrapBKey")," which is only available to client-side web content."),(0,o.kt)("li",{parentName:"ul"},"Knowledge of the user's account password is not sufficient to calculate ",(0,o.kt)("inlineCode",{parentName:"li"},"kB"),"; one must also convince the FxA server to provide a copy of ",(0,o.kt)("inlineCode",{parentName:"li"},"wrapKb"),", which can be protected by operational security measures such as email confirmation loops (or in the future, a 2FA challenge)."),(0,o.kt)("li",{parentName:"ul"},"Data that is encrypted using key material derived from ",(0,o.kt)("inlineCode",{parentName:"li"},"kB")," cannot be used to mount a brute-force guessing attack on the user's password, because it incorporates a full 32 bytes of entropy via ",(0,o.kt)("inlineCode",{parentName:"li"},"wrapKb"),"."),(0,o.kt)("li",{parentName:"ul"},"The user can change their password without changing the value of ",(0,o.kt)("inlineCode",{parentName:"li"},"kB"),", by calculating a new value of ",(0,o.kt)("inlineCode",{parentName:"li"},"wrapKb")," to match the new value of ",(0,o.kt)("inlineCode",{parentName:"li"},"unwrapBKey")," and storing it on the server.")),(0,o.kt)("p",null,"Of course, these security properties depend on the FxA web content behaving as described and assume that the user trusts this code not to be malicious.  A discussion about ensuring the trustworthiness of FxA web content would be both very interesting, and very beyond the scope of this document."),(0,o.kt)("p",null,"We intend all new applications to connect to Firefox Accounts and attached services via OAuth, so we assume familiarity with the ",(0,o.kt)("a",{parentName:"p",href:"https://oauth.net/2/"},"OAuth 2.0 standard")," and will be proposing an extension of it in this document.  We will use the ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/wg/jose/"},'Javascript Object Signing and Encryption ("JOSE")')," family of specifications for the details of cryptographic operations and data formats."),(0,o.kt)("h3",{id:"requirements"},"Requirements"),(0,o.kt)("p",null,"The current Firefox Sync authentication protocol delivers the raw value of ",(0,o.kt)("inlineCode",{parentName:"p"},"kB")," to the application, making it unsuitable for applications that want their own encryption keys but do not need access to sync data.  By contrast, the current FxA OAuth protocol does not provide any access to key material at all."),(0,o.kt)("p",null,"The purpose of this document is thus twofold:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"To propose a way to derive multiple purpose-specific keys from this single source of master key material, so we can use distinct keys for distinct applications."),(0,o.kt)("li",{parentName:"ul"},"To propose a protocol for delivering these keys to applications that is easy for them to integrate, while keeping the user in control of what capabilities are granted to which applications.")),(0,o.kt)("p",null,"To support the desired range of target applications, and to maintain the existing security properties of the Firefox Accounts system, we will observe the following requirements when designing the extended authorization flow:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We must maintain the core security promise of the existing FxA protocol: ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key material is never seen by the FxA server")),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Key material may, however, be handled by client-side web content from accounts.firefox.com, and the user trusts that said code is not malicious."))),(0,o.kt)("li",{parentName:"ul"},"We must allow OAuth reliers to offer a corresponding promise: ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key material need never be seen by the application servers")),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"As above, the user must trust that application client code will keep the key material confidential."))),(0,o.kt)("li",{parentName:"ul"},"We must ensure that ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"the user's master key material is never exposed to relying applications")),".",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Applications should receive only purpose-specific key material according to capabilities approved by the user."))),(0,o.kt)("li",{parentName:"ul"},"The flow should be usable from ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"web-based applications running in any modern browser")),"."),(0,o.kt)("li",{parentName:"ul"},"The flow should be usable from ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"native apps"))," that follow the OAuth best-practices from this ",(0,o.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/draft-ietf-oauth-native-apps-12"},"internet draft"),".")),(0,o.kt)("p",null,"Our approach to satisfying these requirements is based on the following key ideas:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Control what keys each application can receive in the same way we control what services it can access: via OAuth scopes."),(0,o.kt)("li",{parentName:"ul"},"Use client-side web content from accounts.firefox.com to produce derived key material during the OAuth authorization flow."),(0,o.kt)("li",{parentName:"ul"},"Securely communicate key material back to the client application by encrypting it for transit during the OAuth redirect dance.")),(0,o.kt)("p",null,"We explore each point in turn in the following sections, which are presented in the order in which we intend to build and ship them."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"#data-model"},"Data Model")," defines the overarching view of how we'll model access to encryption keys via special OAuth scopes\n",(0,o.kt)("a",{parentName:"p",href:"#protocol-flow"},"Protocol Flow")," defines an extension to the OAuth authorization flow that can securely transmit key material from FxA web content back to the relying application.\n",(0,o.kt)("a",{parentName:"p",href:"#key-rotation-and-revocation"},"Key Rotation and Revocation")," discusses how relying applications will be expected to manage the inevitable rotation of encryption keys.\n",(0,o.kt)("a",{parentName:"p",href:"#application-specific-keys"},"Application-Specific Keys")," defines the first kind of key that will be available via this flow - a dedicated key for internal use by the relying application.\n",(0,o.kt)("a",{parentName:"p",href:"#granting-access-to-sync-data"},"Granting Access to Sync Data")," defines the second use-case that will be made available via this flow - OAuth-mediated access to existing Firefox Sync data.\nFinally, ",(0,o.kt)("a",{parentName:"p",href:"#risks-and-mitigations"},"Risks and Mitigations")," steps back to discuss the overall security considerations involved in designing this system."),(0,o.kt)("h3",{id:"data-model"},"Data Model"),(0,o.kt)("p",null,"The ability to access a particular set of encrypted data, or to access a service requiring a particular key, can be viewed as a ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"capability"))," that applications may be granted or denied or have revoked at the user's discretion.  OAuth has a well-understood mechanism for managing the authorization of particular capabilities to particular applications: ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"scopes")),"."),(0,o.kt)("p",null,"We will use this as the basis for our data model:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"Some OAuth scopes have a corresponding bundle of key material, which an application will receive when the user grants its request for that scope.")))),(0,o.kt)("p",null,"Precisely which scopes exist, and which have corresponding key material, is an implementation decision that is left to the identity provider.  For Firefox Accounts we intend to derive scope-specific key material from the user's master key ",(0,o.kt)("inlineCode",{parentName:"p"},"kB"),", but this is an implementation detail that is not exposed to relying applications."),(0,o.kt)("p",null,"Using scopes to define what keys can be accessed by which applications has a number of advantages, and maps well to the existing shape of our OAuth infrastructure:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"We already have a screen that prompts the user what permissions to grant during the OAuth flow, which will extend quite naturally to granting keys."),(0,o.kt)("li",{parentName:"ul"},"We have existing infrastructure to control which scopes can be requested by which reliers, making it easy for us to lock this down to specific apps during initial development."),(0,o.kt)("li",{parentName:"ul"},"Applications can refresh their access to keys after a password reset in the same way they would refresh an ordinary OAuth token, and we can give them the updated key material."),(0,o.kt)("li",{parentName:"ul"},"Using special scopes to opt-in to new features is consistent with e.g. ",(0,o.kt)("a",{parentName:"li",href:"http://openid.net/specs/openid-connect-core-1_0.html#Introduction"},"the OpenID Connect spec"),' and its use of an "openid" scope.')),(0,o.kt)("p",null,"We'll follow prior art from ",(0,o.kt)("a",{parentName:"p",href:"https://developers.google.com/identity/protocols/googlescopes"},"Google\u2019s OAuth 2.0 scopes")," and use URIs to represent permissions that relate to a specific service operated by Mozilla, and short literal strings to represent special permissions that relate directly to the relying application.  We currently have the following specific use-cases in mind:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"App-specific keys")),".  A relying application may request the special ",(0,o.kt)("inlineCode",{parentName:"li"},"app_key")," scope in order to get a unique key just for its own use, and would depend on Firefox Accounts to ensure this key is not shared with other applications.  Only applications that share a redirect_uri origin would be able to access the same ",(0,o.kt)("inlineCode",{parentName:"li"},"app_key")," key."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"Firefox Notes")),".  This application consists of a new server-side storage API and corresponding client-side application code.  The application will request the scope ",(0,o.kt)("inlineCode",{parentName:"li"},"https://identity.mozilla.com/apps/notes")," which will allow it to retrieve both some purpose-specific encryption keys, and an OAuth token that can be used to access the storage API."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"Sync keys")),".  A relying application may request the scope ",(0,o.kt)("inlineCode",{parentName:"li"},"https://identity.mozilla.com/apps/sync")," in order to get access to the user's sync data.  In this case Firefox Accounts would be responsible for ensuring that it provides the same encryption keys as used by existing sync clients, to ensure backwards compatibility.")),(0,o.kt)("p",null,"So we'll end up with a set of supported scopes that looks something like this:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null}),(0,o.kt)("th",{parentName:"tr",align:null}))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"app_key"),(0,o.kt)("td",{parentName:"tr",align:null},"Get key material that's private to the redirect_uri origin of the requesting application.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://identity.mozilla.com/apps/notes")),(0,o.kt)("td",{parentName:"tr",align:null},"Get read/write access to the Notes API, and receive the Notes encryption key.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://identity.mozilla.com/apps/notes.readonly")),(0,o.kt)("td",{parentName:"tr",align:null},"Get read-only access to the Notes API, and receive the Notes encryption key.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://identity.mozilla.com/apps/sync")),(0,o.kt)("td",{parentName:"tr",align:null},"Get read/write access to the entire Sync API, and receive the Sync encryption key.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://identity.mozilla.com/apps/sync/bookmarks")),(0,o.kt)("td",{parentName:"tr",align:null},'Get read/write access to the Sync API "bookmarks" collection, and receive the Sync encryption key.')),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://identity.mozilla.com/apps/sync/bookmarks.readonly")),(0,o.kt)("td",{parentName:"tr",align:null},'Get read-only access to the Sync API "bookmarks" collection, and receive the Sync encryption key.')))),(0,o.kt)("p",null,"Other scopes may be added in the future if and when we deploy more services that support end-to-end encryption.  We defer the precise details of how these keys are generated to a later section of this document, since it is an implementation detail that is hidden from the relying application."),(0,o.kt)("p",null,"For now, the key point is that ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"for a given set of scopes, there is a corresponding bundle of key material"))," that is generated in client-side FxA web content during the authentication process."),(0,o.kt)("p",null,"We will provide a standardized representation of key material using ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7517"},"JSON Web Keys"),". Reliers that request scopes with associated keys, should expect to receive a JSON object mapping scope strings to JWK objects.  For example, if a relier requested the following scopes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"profile https://identity.mozilla.com/apps/notes https://identity.mozilla.com/app/sync\n")),(0,o.kt)("p",null,"Then in addition to the usual OAuth access and refresh tokens, it would expect to receive a JSON object containing keys like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "https://identity.mozilla.com/apps/notes": {\n        "kid": "<opaque key identifier>",\n        "k": "<notes encryption key, b64url-encoded>",\n        "kty": "oct"\n    },\n    "https://identity.mozilla.com/apps/sync": {\n        "kid": "<opaque key identifier>",\n        "k": "<sync encryption keys, b64url-encoded>",\n        "kty": "oct"\n    }\n}\n')),(0,o.kt)("p",null,"To maintain the existing security properties of FxA, we need to deliver this bundle of key material back to the client application without exposing it to either the FxA server, or the receiving server on the application side."),(0,o.kt)("h3",{id:"protocol-flow"},"Protocol Flow"),(0,o.kt)("p",null,"Since we must operate within a standard OAuth protocol flow, there is no way for FxA web content to communicate directly with the client application.  The key material must transit the OAuth redirect flow and hence be handled by servers on both sides.  To guard against exposure, we will encrypt it for transit using public-key cryptography with an ephemeral key generated at the start of the OAuth flow."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Protocol Flow Diagram",src:n(20013).Z,width:"1591",height:"1395"})),(0,o.kt)("p",null,"At a high level, the flow will operate as follows:"),(0,o.kt)("ol",{start:0},(0,o.kt)("li",{parentName:"ol"},"When initiating the OAuth dance, the client application generates a new P-256 ECDH keypair, stores the private key locally, and includes the JWK-serialized public key in its request to the FxA authorization endpoint."),(0,o.kt)("li",{parentName:"ol"},'FxA web content is loaded, and prompts the user to enter their password and to grant access to the application. If granted then it will do the following before continuing with the standard OAuth dance:\n0. Authenticate to the FxA server via the onepw protocol, to obtain the master key material kB.\n0. Use HKDF to derive the requested scope-specific keys.\n0. Serialize the derived key material to a JSON object of JWKs as shown in the previous section.\n0. Encrypt the bundle of key material to the provided public key, serializing the result into a JWE using using alg="ECDH-ES" and enc="A256GCM".\n0. Store the resulting JWE on the FxA servers for later retrieval by the client application.'),(0,o.kt)("li",{parentName:"ol"},"The OAuth dance completes as usual and redirects back to the client application, which receives an authorization code."),(0,o.kt)("li",{parentName:"ol"},"The client application passes the authorization code to the FxA server to complete the OAuth flow.  In addition to the usual access token, it receives back the JWE containing key material from step (2). The FxA server deletes the JWE from its database."),(0,o.kt)("li",{parentName:"ol"},"The client application uses its saved ECDH private key to decrypt the JWE and retrieve the granted key material, discarding the private key after use.")),(0,o.kt)("p",null,"The important security properties of this flow include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},'Encrypting the key material with "ECDH-ES" at step (2d) means that the resulting JWE can only be decrypted by the application\'s private key.  It can thus be stored temporarily on the FxA servers without the server being able to decrypt it.'),(0,o.kt)("li",{parentName:"ul"},"The use of an ephemeral keypair in step (1) means that the relier can receive the encrypted key material without its supporting servers being able to decrypt the JWE when we redirect back to the application."),(0,o.kt)("li",{parentName:"ul"},"The JWE containing encrypted key material has the same access controls as the corresponding OAuth token:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"It is not included directly in redirect URL parameters, so it can't be snooped from e.g. referer logs and exposed to potential offline analysis."),(0,o.kt)("li",{parentName:"ul"},"It can only be obtained by providing the matching authorization code at the end of the OAuth flow."),(0,o.kt)("li",{parentName:"ul"},"The server is free to delete the JWE after it has been fetched by the client, reducing the likelihood of it leaking in e.g. a server-side compromise."),(0,o.kt)("li",{parentName:"ul"},"The server is free to delete the JWE after some period of time has elapsed, to guard against abandoned login flows."))),(0,o.kt)("li",{parentName:"ul"},"Since there are no static keys in this flow, there is ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"no authentication"))," on the ephemeral ECDH key or the resulting JWE.  Instead we depend on the existing mechanisms built into OAuth, such as the use of TLS certificates to authenticate the provider, and pre-registration of known redirect URLs to authenticate the relier.")),(0,o.kt)("p",null,"As a concrete example, below is the sequence of steps that would be involved in a new application requesting an app-specific encryption key via this enhanced OAuth flow."),(0,o.kt)("p",null,"We assume that the application has previously registered as an OAuth client with the following metadata:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    client_id:        ExampleApp\n    redirect_uri:        https://example.com/oauth_complete\n")),(0,o.kt)("p",null,"Moreover, we assume that is is a ",(0,o.kt)("em",{parentName:"p"},"public")," OAuth client running entirely on the user's machine, such as a single-page-web-app or a native mobile app.  It therefore needs to use ",(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7636"},"PKCE")," to ensure integrity of its OAuth flow."),(0,o.kt)("p",null,'To begin, the example client application generates a random ECDH keypair and stores it in its local state. It may optionally include a "kid" field to distinguish between keys used in multiple concurrent requests:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'    {\n"kid":"XXXYYYZZZ",\n"kty": "EC",\n"crv": "P-256",\n         "d": "KXAjjEr4KT9UlYI4BE0BefVdoxP8vqO389U7lQlCigs",\n        "x": "SiBn6uebjigmQqw4TpNzs3AUyCae1_sG2b9Fzhq3Fyo",\n        "y": "q99Xq1RWNTFpk99pdQOSjUvwELss51PkmAGCXhLfMV4"\n    }\n')),(0,o.kt)("p",null,'It then directs the user\'s user-agent to navigate to the FxA OAuth endpoint, requesting the scopes "profile" and "app_key", and providing the public half of its keypair as an additional b64url-encoded request parameter ',(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"keys_jwk")),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'GET https://accounts.firefox.com/oauth/signin?client_id=ExampleApp\n&scope=profile+app_key\n&state=XYZ987\n&code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw+cM=\n&keys_jwk=BASE64URL-ENCODE({"kid":"XXXYYYZZZ","kty":"EC","crv":"P-256","x":"SiBn6uebjigmQqw4TpNzs3AUyCae1_sG2b9Fzhq3Fyo","y":"q99Xq1RWNTFpk99pdQOSjUvwELss51PkmAGCXhLfMV4"})\n')),(0,o.kt)("p",null,"The web content loaded from accounts.firefox.com prompts the user for their password, and asks whether they would like to authorize the application to use encryption keys from their account.  If the user agrees, the page uses their password to authenticate to the FxA server and generate an application-specific encryption key, serializing it into a JSON object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'    {\n    "app_key": {\n            "kid": "20170101123456-ABCDEF123456",\n            "k": "mTBrnxQxUwvzmD \u2026 Gh4x75AnrMCcFqmxb",\n            "kty": "oct"\n        }\n}\n')),(0,o.kt)("p",null,'It then encrypts this key material to the provided JWK using alg="ECDH-ES" and enc="A256GCM" on curve "P-256".  Following the procedure defined in the ',(0,o.kt)("a",{parentName:"p",href:"https://tools.ietf.org/html/rfc7516"},"JWE spec"),", this involves:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Parsing the provided JWK and checking that it's a valid ECDH key on curve P-256."),(0,o.kt)("li",{parentName:"ul"},"Randomly generating an ephemeral ECDH key to be used only for this encryption."),(0,o.kt)("li",{parentName:"ul"},"Using ECDH key agreement with our ephemeral key and the provided JWK to generate a symmetric encryption key."),(0,o.kt)("li",{parentName:"ul"},"Discarding the private component of our ephemeral key."),(0,o.kt)("li",{parentName:"ul"},"Encrypting the key bundle with the agreed symmetric key using AES-256-GCM."),(0,o.kt)("li",{parentName:"ul"},"Formatting the result as a JWE, including the public component of our ephemeral key in the header.")),(0,o.kt)("p",null,"The result is a string containing a JWE in compact serialization (shown here with encoding expanded for clarity):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'BASE64URL({\n"alg":"ECDH-ES",\n"enc": "A256GCM",\n"epk": {\n    "kty": "EC",\n    "crv": "P-256",\n    "x": "T2bouFfRHonsP3UW2Uwfx_N1HYkZmOlpTJ6XFm2Pf5U",\n    "y": "HA9LB1pWKMG_C28t9a3FY1yVxTfHKoVg4SwHlIbYBYw"\n}\n}).                            // b64 JWE header\n"".                            // no content key\n"AxY8DCtDaGlsbGljb3RoZQ".                // b64 IV\n"KDlTtXcTGufMYm \u2026 4HffxfmqCHXaI9wOGY".        // b64 ciphertext\n"Mz-VPPyU4RlcuYv1IwIvzw"                // b64 authentication tag\n')),(0,o.kt)("p",null,"FxA web content submits this JWE back to the server when authorizing the OAuth grant.  The user-agent is redirected back to the client application with an authorization code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/oauth_complete?state=XYZ987&code=ABC123\n")),(0,o.kt)("p",null,'The client application receives the redirect, checks the "state" token against its local state, and posts the authorization code to the Firefox accounts server:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"POST /authorization HTTP/1.1\n    Host: oauth.accounts.firefox.com\n    Content-Type: application/x-www-form-urlencoded\n\ngrant_type=authorization_code&\ncode=ABC123&\ncode_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n")),(0,o.kt)("p",null,"The server responds with both the OAuth access token, and the corresponding JWE of key material:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'    HTTP/1.1 200 OK\n    Content-Type: application/json\n\n    {\n        "access_token": "xxxyyyzzz",\n        "keys_jwe": "3tF3md \u2026 <JWE data in compact encoding> \u2026 kXveOy"\n    }\n')),(0,o.kt)("p",null,'The client application uses its stored private key to decrypt the JWE and retrieve the key material.  It now holds both an access token with scope "profile" that can be used to access information about the user, and an encryption key that is specific to the application.'),(0,o.kt)("h3",{id:"key-rotation-and-revocation"},"Key Rotation and Revocation"),(0,o.kt)("p",null,'Reliers must be prepared for a user\'s encryption keys to change over time, for example if they forget their account password and have to reset it.  To help detect when this occurs, each key includes a unique identifier in the "kid" field, and we guarantee the following semantics:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"When the key corresponding to a particular scope changes, all OAuth tokens that have that scope will be invalidated."),(0,o.kt)("li",{parentName:"ul"},'When the key corresponding to a particular scope changes, the "kid" field for the new key will be lexicographically greater than the "kid" field for the old key.')),(0,o.kt)("p",null,"Applications that use encryption keys obtained via this flow will be expected to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Regularly check the validity of their OAuth tokens, and prompt the user to reconnect if the token has been invalidated."),(0,o.kt)("li",{parentName:"ul"},'Explicitly track the "kid" of the encryption keys in use, and reject attempts to use operate with older values of "kid".')),(0,o.kt)("p",null,"We do not specify a mechanism for retrieving old versions of a key, and reliers should not assume that this will be possible in practice."),(0,o.kt)("h3",{id:"deriving-scoped-keys-ks"},"Deriving Scoped Keys (kS)"),(0,o.kt)("p",null,"For each new application that wants key material, we will calculate an appropriate key via careful application of HKDF-SHA256 to the user's master key ",(0,o.kt)("inlineCode",{parentName:"p"},"kB"),".  We want to be able to generate the key in a way that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ensures that distinct applications receive distinct keys."),(0,o.kt)("li",{parentName:"ul"},"Allows for easy key rotation on a per-application basis.")),(0,o.kt)("p",null,"The process for calculating the key corresponding to a requested scope will be as follows:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Authenticate to the FxA server via the existing onepw protocol, to obtain:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"the account userid ",(0,o.kt)("inlineCode",{parentName:"li"},"uid"),", an opaque 16-byte string unique to the user."),(0,o.kt)("li",{parentName:"ul"},"the account master key ",(0,o.kt)("inlineCode",{parentName:"li"},"kB"),", a 32-byte cryptographically-strong key."))),(0,o.kt)("li",{parentName:"ul"},"Pass the requested scope to the FxA server, which will validate it and return the following information:",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"scoped_key_identifier")),': a unique URI identifying the requested scoped key, after canonicalization and removal of modifiers such as ".readonly".',(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Example: ",(0,o.kt)("inlineCode",{parentName:"li"},"https://identity.mozilla.com/apps/notes")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_secret")),": a 32-byte string of additional entropy specific to this scoped key, which we can use to manage key rotation on a per-scope basis."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_timestamp")),": a 10-digit number. The timestamp at which this scoped key most recently changed (due to either a change in the underlying value of kB, or a change in the value of key_rotation_secret). This value is the UNIX epoch timestamp in UTC.")))),(0,o.kt)("p",null,"An example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'\n> {\n>    "clientid": "foobar",\n>    "scope": "https://identity.mozilla.com/apps/notes.readonly+profile"\n> }\n\n< {\n<    "clientId": "foobar",\n<    "clientName": "notes client",\n<    "scopedKeys": {\n<    "https://identity.mozilla.com/apps/notes.readonly": {\n<        scoped_key_identifier: "https://identity.mozilla.com/apps/notes",\n<        key_rotation_secret: "abcdef123456", // different for each user,\n<        key_rotation_timestamp: 1234567890   // specific to each user\n<                                             // auth-server-db -> verifierSetAt\n<        }\n<    }\n< }\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Derive a 16-byte key fingerprint ",(0,o.kt)("inlineCode",{parentName:"li"},"kSfp")," and a 32-byte key ",(0,o.kt)("inlineCode",{parentName:"li"},"kS")," via HKDF as follows:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},' kSfp + kS = HKDF-SHA256(kB + key_rotation_secret,\n                         size=16 + 32,\n                         salt=uid,\n                         context="identity.mozilla.com/picl/v1/scoped_key\\n"\n                         scoped_key_identifier)\n')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Form the key id for this scoped key as a combination of ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_timestamp"))," as a base-10 integer string, and the key fingerprint ",(0,o.kt)("inlineCode",{parentName:"li"},"kSfp"),":")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'    kid =    scoped_key_timestamp + "-" + kSfp\n')),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},'Example:  "1510628805-ABCDEF1234567890"')),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Return the key as a JWK with kS as the key material and kid as the key identifier.")),(0,o.kt)("p",null,"Important properties of this derivation include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Including the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"scoped_key_identifier"))," in the HKDF context ensures that independent scopes will receive independent keys."),(0,o.kt)("li",{parentName:"ul"},"In the event of a compromise of a specific application or service, the key for the corresponding scope can be rotated or revoked by changing ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_secret"))," on the FxA server, without needing to disrupt ",(0,o.kt)("inlineCode",{parentName:"li"},"kB"),"  or any other unrelated keys."),(0,o.kt)("li",{parentName:"ul"},"Including a timestamp in the ",(0,o.kt)("inlineCode",{parentName:"li"},"kid")," ensures that ids will sort lexicographically and allow receiving applications to identify stale keys."),(0,o.kt)("li",{parentName:"ul"},"Including a fingerprint of the key material derived extracted from the same call to HKDF, allows us to ensure the ",(0,o.kt)("inlineCode",{parentName:"li"},"kid")," is unique to the key without having it reveal any information about the key itself.")),(0,o.kt)("p",null,"In order to simplify initial development, we will default ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_secret"))," to 32 zero bytes for all scopes.  Reserving its place in the definition here means we have a well-defined way to rotate keys when we need to in future."),(0,o.kt)("p",null,"With that general definition set, let's now look at some concrete instantiations of it."),(0,o.kt)("h4",{id:"application-specific-keys"},"Application Specific Keys"),(0,o.kt)("p",null,"To allow other teams to quickly prototype new applications that use end-to-end encryption and bootstrap from the existing FxA user-base, we want to allow application-specific keys to be obtained without having to coordinate any special configuration changes in FxA."),(0,o.kt)("p",null,"From the point-of-view of the relying application, it need only request the special scope ",(0,o.kt)("inlineCode",{parentName:"p"},"app_key")," in order to receive a unique key just for its own use.  Internally to Firefox Accounts, we will allocate a unique ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"scoped_key_identifier"))," for that application and use it to generate its key."),(0,o.kt)("p",null,'We will uniquely identify an application by the origin of its redirect URI, allowing a single logical "application" to be associated with multiple OAuth client_ids while preventing unrelated applications from accessing each other\'s keys.  For example, the "lockbox" application would have separate client_id values for its mobile applications and the desktop WebExtension, all of which share an origin for their redirect_uri:'),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"client_id"),(0,o.kt)("th",{parentName:"tr",align:null},"description"),(0,o.kt)("th",{parentName:"tr",align:null},"redirect_uri"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"7a7c6353e0a1a838"),(0,o.kt)("td",{parentName:"tr",align:null},"Lockbox WebExtension"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://lockbox.mozilla.com/oauth/webext"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"cb1f2de3bdb32a5c"),(0,o.kt)("td",{parentName:"tr",align:null},"Lockbox for Android"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://lockbox.mozilla.com/oauth/android"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"ed0568ab029eecd8"),(0,o.kt)("td",{parentName:"tr",align:null},"Lockbox for iOS"),(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"https://lockbox.mozilla.com/oauth/ios"))))),(0,o.kt)("p",null,"When one of these client_ids requests the ",(0,o.kt)("inlineCode",{parentName:"p"},"app_key")," scope, the Firefox Accounts server will:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Look up the corresponding ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"redirect_uri")),", and extract its origin as ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"app_origin")),"."),(0,o.kt)("li",{parentName:"ul"},"Calculate ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"scoped_key_identifier"))," = ",(0,o.kt)("inlineCode",{parentName:"li"},"app_key: + urlencode(app_origin)")),(0,o.kt)("li",{parentName:"ul"},"Look up the corresponding values of ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_secret"))," and ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("em",{parentName:"strong"},"key_rotation_timestamp")),"."),(0,o.kt)("li",{parentName:"ul"},"Return the scoped key information to FxA web content to calculate the derived key.")),(0,o.kt)("h4",{id:"applications-with-a-service-component"},"Applications with a Service Component"),(0,o.kt)("p",null,"Some applications, such as Firefox Notes, consist of both a client-side application and a server-side API hosted by Mozilla.  We will allocate a unique scope string for each such application, which can be used both for obtaining the corresponding encryption keys, and for checking permissions to access the server-side API."),(0,o.kt)("p",null,"For Firefox Notes we will use the scope ",(0,o.kt)("inlineCode",{parentName:"p"},"https://identity.mozilla.com/apps/notes"),", and this will also be the value of ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"scoped_key_identifier")),"."),(0,o.kt)("h3",{id:"granting-access-to-sync-data"},"Granting Access to Sync Data"),(0,o.kt)("p",null,"The proposed flow can also be used to grant access to the existing Firefox Sync service, but it will need some special treatment to ensure backwards-compatibility with existing Sync clients and infrastructure."),(0,o.kt)("p",null,"A relying application may request the scope ",(0,o.kt)("inlineCode",{parentName:"p"},"https://identity.mozilla.com/apps/sync")," in order to get access to the user's sync data.  If it requires access to only a particular data type, it can request a more specific scope such as ",(0,o.kt)("inlineCode",{parentName:"p"},"https://identity.mozilla.com/apps/sync/bookmarks")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"https://identity.mozilla.com/apps/sync/history"),"."),(0,o.kt)("p",null,"If the user grants the authorization request then, in addition to an OAuth access token with which it can access the sync storage service, the application will receive 64 bytes of key material derived from the user's FxA master key according to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'HKDF-SHA256(kB, size=64 context="identity.mozilla.com/picl/v1/oldsync")\n')),(0,o.kt)("p",null,"This is the same derivation done by existing Firefox Sync clients, and would be done in client-side web content as part of the FxA login flow."),(0,o.kt)("p",null,'The existing Sync service does not support using different encryption keys to access different subsets of its data, so we must give the same key material for scope "sync" or for "sync:bookmarks".  But we can enforce access restrictions at the service level by ensuring that an access token with scope "sync:bookmarks" cannot be used to retrieve the user\'s encrypted history data.'),(0,o.kt)("h3",{id:"test-vectors-wip"},"Test Vectors (WIP)"),(0,o.kt)("p",null,"The above description of protocol flow was designed for human-readability.  For completeness, this section specifies the specific concrete values that would be expected at each step of the flow.  To avoid ambiguity we will represent ASCII strings like 'literal string' and show raw bytes in hex format as ","<","ABCDEF",">",".  Linebreaks within values are for readability only."),(0,o.kt)("p",null,"To begin, assume that the relying application has been registered with FxA with the following client details:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    client_id:        'a4dea33c7b40fc34'\n    redirect_uri:        'https://example.com/oauth_complete'\n    public_client:    True\n")),(0,o.kt)("p",null,"As a public client, it will need to use PKCE to secure its login flow.  It will begin the OAuth dance by randomly generating an OAuth state token and a PKCE code_verifier, and calculating the corresponding code_challenge via SHA256:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    state:            'd50209fc504a8393'\n    code_verifier:    'dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk'\n    code_challenge:    'E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw+cM'\n")),(0,o.kt)("p",null,"It will also randomly generate an ephemeral ECDH keypair to secure delivery of the scoped keys.  Assume it generates a private key with the following details:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'    {\n        "kty": "EC",\n        "crv": "P-256",\n        "d":   "KXAjjEr4KT9UlYI4BE0BefVdoxP8vqO389U7lQlCigs",\n        "x":   "SiBn6uebjigmQqw4TpNzs3AUyCae1_sG2b9Fzhq3Fyo",\n        "y":   "q99Xq1RWNTFpk99pdQOSjUvwELss51PkmAGCXhLfMV4"\n    }\n')),(0,o.kt)("p",null,"Rendering the public-key component to JSON with sorted keys and no whitespace, then base64url-encoding, the client will transmit its public key encoded as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    keys_jwk:    'eyJjcnYiOiJQLTI1NiIsImt0eSI6IkVDIiwieCI6IlNpQm42dWViamlnbVF\nxdzRUcE56czNBVXlDYWUxX3NHMmI5RnpocTNGeW8iLCJ5IjoicTk5WHExUld\nOVEZwazk5cGRRT1NqVXZ3RUxzczUxUGttQUdDWGhMZk1WNCJ9'\n")),(0,o.kt)("p",null,"Thus, it will begin the OAuth dance by redirecting to Firefox Accounts at the following URL:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"GET https://accounts.firefox.com/oauth/signin?client_id=a4dea33c7b40fc34\n&scope=profile+app_key\n&state=d50209fc504a8393\n&code_challenge=E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw+cM\n&code_challenge_method=S256\n&keys_jwk=eyJjcnYiOiJQLTI1NiIsImt0eSI6IkVDIiwieCI6IlNpQm42dWVi\namlnbVFxdzRUcE56czNBVXlDYWUxX3NHMmI5RnpocTNGeW8iLCJ5IjoicTk5WH\nExUldOVEZwazk5cGRRT1NqVXZ3RUxzczUxUGttQUdDWGhMZk1WNCJ9\n")),(0,o.kt)("p",null,"The web content running on accounts.firefox.com will prompt the user for their password, and use it to retrieve their account uid (a 16-byte identifier) and encryption key kB (a 32-byte secret value):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"uid:    <aeaa1725c7a24ff983c6295725d5fc9b>\nkB:    <8b2e1303e21eee06a945683b8d495b9bf079ca30baa37eb8392d9ffa4767be45>\n")),(0,o.kt)("p",null,"It will also pass the provided client_id and scopes to the FxA server for validation, and will receiving back the client's redirect_uri and the details necessary to derived scoped keys:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    scoped_key_identifier:  'app_key:https%3A//example.com'\n    key_rotation_secret:    <517d478cb4f994aa69930416648a416fdaa1762c5abf401a2acf11a0f185e98d>\n    key_rotation_timestamp: 1510726317\n")),(0,o.kt)("p",null,"Using this information, it will calculate the scoped key and fingerprint via HKDF as defined in the section above, giving:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"kSfp:    <56873e11bf48a684c836ea3d965edb8c>\nkS:    <2a46e4d7f434a027139a081e0c7ebcf346d0af18a7d912eee43d3435c25acdd4>\n")),(0,o.kt)("p",null,"Serialized into a JSON object mapping scopes to JWK objects, this key would be encoded as the string:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'    keys_bundle:    \'{"app_key":{"k":"Kkbk1_Q0oCcTmggeDH6880bQrxin2RLu5D00NcJazdQ","kid":"1510726317-Voc-Eb9IpoTINuo9ll7bjA","kty":"oct"}}\'\n')),(0,o.kt)("p",null,"FxA web content will then encrypt this string to the public key provided in ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("em",{parentName:"strong"},"keys_jwk")),", using a randomly-generated ECDH key of its own.   Assume it generates an ephemeral private key with the following details:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n    "kty": "EC",\n    "crv": "P-256",\n    "d": "X9tJG0Ue55tuepC-6msMg04Qv5gJtL95AIJ0X0gDj8Q",\n    "x": "N4zPRazB87vpeBgHzFvkvd_48owFYYxEVXRMrOU6LDo",\n    "y": "4ncUxN6x_xT1T1kzy_S_V2fYZ7uUJT_HVRNZBLJRsxU"\n}\n')),(0,o.kt)("p",null,"And uses the the following IV for the encryption:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    iv:    <ff4b187fb1dd5ae46fd9c334>\n")),(0,o.kt)("p",null,"Then it will generate an encrypted key bundle equal to:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    kwys_jwe:    'eyJhbGciOiJFQ0RILUVTIiwiZW5jIjoiQTI1NkdDTSIsImVwayI6eyJjcnYi\nOiJQLTI1NiIsImt0eSI6IkVDIiwieCI6Ik40elBSYXpCODd2cGVCZ0h6RnZrd\nmRfNDhvd0ZZWXhFVlhSTXJPVTZMRG8iLCJ5IjoiNG5jVXhONnhfeFQxVDFren\nlfU19WMmZZWjd1VUpUX0hWUk5aQkxKUnN4VSJ9fQ.._0sYf7HdWuRv2cM0.U5\nZK5BYZWhLluS7q4y4ZFW1t_sSPt4me-5Ltscs1dWpoPnIZa3xEng2xsUOBaHf\nBra6m4wdgzrg6qINhBz0LuDwAfrHOtfRlpqeV3nrKhas1mGEQzr6lD4zBVYpm\nF_chm61IySnVxprsA1BulinIER2EIJbA.3Lh7cwCocbA2VkBBnsKgXA'\n")),(0,o.kt)("p",null,"Finally, it will store this JWE on the server and allocate an OAuth authorization code with which the client application may retrieve it:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    code:        '67675750e08865338ed540f9656c4102'\n")),(0,o.kt)("p",null,"Then redirect back to the client with the authorization code and state:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},"    HTTP/1.1 301 Moved Permanently\nLocation: https://example.com/oauth_complete?\nstate=d50209fc504a8393&\ncode=67675750e08865338ed540f9656c4102\n")),(0,o.kt)("p",null,"Upon receiving the redirect, the client can prove its knowledge of the code verifier to exchange the authorization code for an access token and the encrypted key bundle:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-text"},'POST /authorization HTTP/1.1\n    Host: oauth.accounts.firefox.com\n    Content-Type: application/x-www-form-urlencoded\n\n\ngrant_type=authorization_code&\ncode=67675750e08865338ed540f9656c4102&\ncode_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n\n...\n\nHTTP/1.1 200 OK\n    Content-Type: application/json\n\n    {\n        "access_token": "9ebeb2bd2003c7d0ec3cd585903955f93e0b51c46b2b917f",\n        "keys_jwe": "eyJhbGciOiJFQ0RILUVTIiwiZW5jIjoiQTI1NkdDTSIsImVwayI6eyJjc\nnYiOiJQLTI1NiIsImt0eSI6IkVDIiwieCI6Ik40elBSYXpCODd2cGVCZ\n0h6RnZrdmRfNDhvd0ZZWXhFVlhSTXJPVTZMRG8iLCJ5IjoiNG5jVXhON\nnhfeFQxVDFrenlfU19WMmZZWjd1VUpUX0hWUk5aQkxKUnN4VSJ9fQ.._\n0sYf7HdWuRv2cM0.U5ZK5BYZWhLluS7q4y4ZFW1t_sSPt4me-5Ltscs1\ndWpoPnIZa3xEng2xsUOBaHfBra6m4wdgzrg6qINhBz0LuDwAfrHOtfRl\npqeV3nrKhas1mGEQzr6lD4zBVYpmF_chm61IySnVxprsA1BulinIER2E\nIJbA.3Lh7cwCocbA2VkBBnsKgXA"\n    }\n')),(0,o.kt)("p",null,"And finally, it can use its saved ECDH private key to decrypt the JWE and retreive the seralized key bundle."),(0,o.kt)("h3",{id:"risks-and-mitigations"},"Risks and Mitigations"),(0,o.kt)("h4",{id:"exposure-of-key-material-to-fxa-servers"},"Exposure of key material to FxA servers"),(0,o.kt)("p",null,"Key material is handled in client-side web content, and only stored temporarily on the server in encrypted form.  An actively malicious FxA server could send compromised web content that exfiltrates the key material, but that's already possible in today's sync login flow, so the proposal in this document isn't making it any worse."),(0,o.kt)("h4",{id:"exposure-of-key-material-to-relying-application-servers"},"Exposure of key material to relying application servers"),(0,o.kt)("p",null,"Relying applications are only given access to specific derived key material, and it's encrypted for transit during the OAuth dance.  By having the client pass in an ephemeral key at the beginning of the dance, we avoid exposing the derived keys in the redirect at the end.  This will allow the application to keep the key material on the local machine, although of course we cannot actively prevent it from then exposing the keys elsewhere."),(0,o.kt)("h4",{id:"side-channel-leaks-from-web-content"},"Side-channel leaks from Web Content"),(0,o.kt)("p",null,"This scheme involves handling key material in web content served from accounts.firefox.com.  It might be possible for other code running in the user's browser or on the user's machine, to observe some side-channel behaviours from this content that would provide information about the keys.  In particular, there is a known side-channel in using standard javascript functions to base64url encode the key material."),(0,o.kt)("p",null,"We can mitigate this by using established primitives from the webcrypto spec, and by using a constant-time base64 encoding library."),(0,o.kt)("h4",{id:"interception-by-another-application"},"Interception by another application"),(0,o.kt)("p",null,"We rely on existing procedures for keeping an OAuth flow secure from eavesdropping or interception, including:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Pre-registration of fixed client redirect URLs"),(0,o.kt)("li",{parentName:"ul"},"Use of a client_secret to authenticate clients with a server-side component"),(0,o.kt)("li",{parentName:"ul"},"Use of ",(0,o.kt)("a",{parentName:"li",href:"https://tools.ietf.org/html/rfc7636"},"PKCE")," to authenticate clients without a server-side component")),(0,o.kt)("p",null,"This proposal does not introduce any additional points at which the key material could be intercepted, because the JWE-encrypted data can only be fetched once the OAuth flow has been successfully completed."),(0,o.kt)("h4",{id:"theft-of-keys-from-client-application"},"Theft of keys from client application"),(0,o.kt)("p",null,"The risk of client applications exposing key material is the same as the risk of them exposing OAuth tokens.  Applications are expected to store both tokens and keys securely on the local machine, or if that is not possible, then to keep them only in memory and request them afresh on application startup.  We should provide libraries for application developers which can handle some of these needs automatically."),(0,o.kt)("h4",{id:"shared-redirect_uri-origins"},"Shared redirect_uri origins"),(0,o.kt)("p",null,'The "app_key" scheme treats the redirect URI origin as a trust boundary, with any URI on an origin being able to receive the app_key key for that origin.  There may be risks here for mutually untrusting apps running in shared-hosting setups or on sub-domains.'),(0,o.kt)("p",null,"We could invent a more fine-grained scheme here, such as allowing a path component in the scoped key identifier.  But the origin is already an established trust boundary for other parts of the web stack so the extra complexity may not be worth it in practice."),(0,o.kt)("h4",{id:"revocation"},"Revocation"),(0,o.kt)("p",null,"We don't have a good story for how to handle revocation of key material, and ultimately I don't think it's possible within the requirements in this document.  If you are going to trust the application to handle keys for client-side encryption, you must confront the fact that it could keep a copy of those keys indefinitely."),(0,o.kt)("p",null,"Instead, we rely on the revocation of access to encrypted data, controlled by the same scope-related access control mechanisms as used in standard OAuth."),(0,o.kt)("h3",{id:"additional-notes-and-content"},"Additional Notes and Content"),(0,o.kt)("p",null,"Notes from a previous proposal that didn't get off the ground:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mail.mozilla.org/pipermail/dev-fxacct/2014-December/001260.html"},"https://mail.mozilla.org/pipermail/dev-fxacct/2014-December/001260.html"))),(0,o.kt)("p",null,"Prior art on keys specifically for in-browser OAuth reliers:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/mozilla/fxa-content-server/commits/c3cc9d4a462e9c96cd702a5e0161065c4d8c0139/docs/relier-keys.md"},"https://github.com/mozilla/fxa-content-server/commits/c3cc9d4a462e9c96cd702a5e0161065c4d8c0139/docs/relier-keys.md"))),(0,o.kt)("p",null,'Related discussion of the pros and cons of the "relier keys" approach linked above:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://bugzilla.mozilla.org/show_bug.cgi?id=1115340#c10"},"https://bugzilla.mozilla.org/show_bug.cgi?id=1115340#c10")),(0,o.kt)("li",{parentName:"ul"},"There's some criticisms of the approach in there that are worth us reviewing, and an alternative proposal of an \"encryption oracle\" architecture with interesting security properties.  But I don't think it's very mobile-app friendly.")),(0,o.kt)("p",null,"The original version of this document:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.google.com/document/d/1IvQJFEBFz0PnL4uVlIvt8fBS_IPwSK-avK0BRIHucxQ/edit"},"https://docs.google.com/document/d/1IvQJFEBFz0PnL4uVlIvt8fBS_IPwSK-avK0BRIHucxQ/edit"))))}u.isMDXComponent=!0},56750:function(e,t,n){t.Z=n.p+"assets/images/fxa-scoped-keys-1-e5701eeb89bfe0593b87c3071a16faaf.png"},20013:function(e,t,n){t.Z=n.p+"assets/images/fxa-scoped-keys-2-828bf00f3b2ddef01993ba8b78645f5d.png"}}]);